---
title: "Workshop"
subtitle: "Data Analysis 4: Immunobiology - Your data presentation"
toc: true
toc-location: right
editor: 
  markdown: 
    wrap: sentence
---

```{r}
#| include: false

library(kableExtra)
```

In this workshop learn how to create density plots to visualise the distribution and gating of the signals and calculate the the percentage of cells in each quadrant of a quadrant gated plot of TNFa_APC_Lin signal against the E_coli_FITC_Lin signal. You will also grow your knowledge of ggplot annotation and data import from googlesheet.

ðŸ’» Annotate ggplots

ðŸ’» Import data from a googlesheet

# Exercises

## Add your data

Enter these in the [BIO00066I Biomedical Sciences class data](https://docs.google.com/spreadsheets/d/104EXdgsiIq-FuRF9Ly9zewEVdpkVWbyOwxSAmiqJepg/edit#gid=0)

The columns you must add are:

-   `apc_mfi`: Mean fluorescence intensity of the logicle transformed TNFa_APC_Lin in the TNF-Î± positive cells

-   `perc_tfna_pos`: % non debris cells that are TNF-Î± positive cells

The other columns are calculations you make along the way and may help you get to the `apc_mfi` and `perc_tfna_pos` values.
The column names are the same as those used in the [Data Analysis 2: Immunobiology - Sample data analysis](../week-2/workshop.html) workshop.

## Set up

ðŸŽ¬ Open the RStudio project you created in the [Data Analysis 2: Immunobiology - Sample data analysis](../week-2/workshop.html) workshop.

ðŸŽ¬ Create a new script called `data-presentation.R`

ðŸŽ¬ Load packages:

```{r}
library(tidyverse)
```

ðŸŽ¬ Save a copy of [live_labelled.csv](data-raw/live_labelled.csv) to your `data-processed` folder.
These cells have been AI cleaned, gated to remove debris and dead cells, and labelled as positive or negative for the E_coli_FITC_Lin and TNFa_APC_Lin signals[^1].

[^1]: [Data Analysis 2: Immunobiology - Sample data analysis](../week-2/workshop.html) workshop has been amended to include the instruction to save these data at the end.

ðŸŽ¬ Import the data:

```{r}
clean_trans_nondebris <- read_csv("data-processed/live_labelled.csv")

```
ðŸŽ¬ I'm also going to select only columns I need to keep my life simple:

```{r}
clean_trans_nondebris <- clean_trans_nondebris |> 
  select(FS_Lin,
         SS_Lin,
         E_coli_FITC_Lin,
         TNFa_APC_Lin,
         antibody,
         treatment,
         tnfa,
         fitc)
```




These are the forward and side scatter, the two logicle-transformed signals the groups (treatment and antibody) and whether the cell is positive or negative for each of the signals. 

ðŸŽ¬ Click on the data frame in the environment window to view it and make sure you have an understanding of the data.

```{r}
#| echo: false
clean_trans_nondebris |> 
  head(n = 10) |> 
  knitr::kable() |> 
  kable_styling() |> 
  scroll_box(height = "200px")

```

ðŸŽ¬ Use `fct_relevel()` to put treatment groups in order so that our graphs are better to interpret.

```{r}
clean_trans_nondebris <- clean_trans_nondebris |> 
  mutate(treatment = fct_relevel(treatment, c("MEDIA",
                                              "LPS",
                                              "ECOLIGreen")))
```

We need to calculate some summary information such as the percent of  TNF-Î± positive cells in each sample and the mean fluorescence intensity of the TNFa_APC_Lin signal in the TNF-Î± positive cells. If you especially hate `R` but are familiar with pivot tables in Excel, then you could use that..... but it would not be as reproducible as using `R` and `tidyverse` functions.

ðŸŽ¬ Calculate the number of cells in each sample:

```{r}
# number of cells in each sample after gating
clean_trans_nondebris_n <-  clean_trans_nondebris |> 
  group_by(antibody, treatment) |> 
  summarise(n_nondebris = n()) 
```
ðŸŽ¬ Click on the dataframe in the environment window to view it and make sure you have an understanding of the summary.

```{r}
#| echo: false
clean_trans_nondebris_n |> 
  knitr::kable() |> 
  kable_styling() |> 
  scroll_box(height = "200px")

```


ðŸŽ¬ Calculate the number of TNF-Î± positive cells in each sample and the mean fluorescence intensity of the TNFa_APC_Lin signal in the TNF-Î± positive cells:


```{r}
## summarise the number of TNF-Î± +'ve cells in each sample  
clean_trans_nondebris_tfna_pos <- clean_trans_nondebris |> 
  filter(tnfa == "TNF-Î± +'ve") |>
  group_by(antibody, treatment) |>
  summarise(n_pos_tnfa = n(),
            mean_apc = round(mean(TNFa_APC_Lin), 2))
```
ðŸŽ¬ Click on the dataframe in the environment window to view it and make sure you have an understanding of the summary.

```{r}
#| echo: false
clean_trans_nondebris_tfna_pos |> 
  knitr::kable() |> 
  kable_styling() |> 
  scroll_box(height = "200px")

```
In order to calculate the percentage of cells that are TNF-Î± positive, we need to join the two summaries together and add a column using `mutate()`.

ðŸŽ¬ Join the summary of the total number of cells in each sample with the summary of the number of TNF-Î± +'ve cells in each sample and calculate the percentage of cells that are TNF-Î± +'ve:

```{r}
## join the summary with the summary of the number of cells in each sample
## and calculate the percentage of cells that are TNF-Î± +'ve
clean_trans_nondebris_tfna_pos <- 
  clean_trans_nondebris_tfna_pos |> 
  left_join(clean_trans_nondebris_n, by = c("antibody", "treatment")) |> 
  mutate(perc_tfna_pos = round(n_pos_tnfa/n_nondebris * 100, 1) )
```

ðŸŽ¬ Click on the dataframe in the environment window to view it and make sure you have an understanding of the summary.

```{r}
#| echo: false
clean_trans_nondebris_tfna_pos |> 
  knitr::kable() |> 
  kable_styling() |> 
  scroll_box(height = "200px")

```

## Distribution of APC TNF-Î± signal with gate

To annotate the distribution of APC TNF-Î± signal with the gate used to define whether the cells are positive or negative for TNF-Î± it is useful to assign that value to a variable that we can use in our plots. We will do the FITC gate value at the same time[^2].

[^2]: You might want to look back at [Quality control 3: Gating to determine a â€˜realâ€™ signal](../week-2/workshop.html#quality-control-3-gating-to-determine-a-real-signal) in the week 2 workshop to remind yourself of how we determined the gate values for the sample data. 


ðŸŽ¬ Assign the gate values to variables:

```{r}
apc_cut <- 2
fitc_cut <- 2
```


### Plot one sample

The pipe (`|>`) allows us to filter the data before plotting it which allows select the sample we want to plot. 

ðŸŽ¬ Plot the distribution of the APC TNF-Î± signal for the MEDIA `treatment` and the ISOTYPE `antibody`:


```{r}
clean_trans_nondebris |> 
    filter(treatment == "MEDIA",
           antibody == "ISOTYPE") |>
  ggplot(aes(x = TNFa_APC_Lin)) +
  geom_density(fill = "gray80") +
  geom_vline(xintercept = apc_cut, 
             color = "red") +
  scale_y_continuous(expand = c(0, 0),
                     limits = c(0, 2.5),
                     name = "Density") +
  scale_x_continuous(name = "Logicle transformed APC TNF-Î± signal") +
  theme_bw()

```
-    `geom_vline()` adds a vertical line to the plot at the value of `apc_cut` which is the gate value we determined for the APC TNF-Î± signal.

-   `geom_density()` is a smoothed version of a histogram and shows the distribution of the data. The fill argument sets the colour of the plot to a light grey.

-   the expand argument in a `scale_x_....` or `scale_y_....` sets the axis line at zero rather than being below it.


#### Plot annotation

You have (at least) three options for adding the summary statistics to the plot.

1.  Most simple: adding in word/googledocs (or whatever you write your report in).

    Save the plot using `ggsave()`, insert as an image into your report and a text box.

2.  In R by hard coding the values in the `geom_text()` function.

```{r}

clean_trans_nondebris |> 
  filter(treatment == "MEDIA",
         antibody == "ISOTYPE") |>
  ggplot(aes(x = TNFa_APC_Lin)) +
  geom_density(fill = "gray80") +
  geom_vline(xintercept = apc_cut, 
             color = "red") +
  geom_text(label = "0.1 % cells\nTNF-Î± +'ve\nMFI = 2.14",
            x = 1.6,
            y = 2.2,
            colour = "red") +
  scale_y_continuous(expand = c(0, 0),
                     limits = c(0, 2.5),
                     name = "Density") +
  scale_x_continuous(name = "Logicle transformed APC TNF-Î± signal") +
  theme_bw()

```


3.  In R and fully reproducibly by using the `clean_trans_nondebris_tfna_pos` dataframe with the summary statistics in `geom_text()`. That dataframe also needs filtering to the sample you are plotting.

```{r}
clean_trans_nondebris |> 
  filter(treatment == "MEDIA",
         antibody == "ISOTYPE") |>
  ggplot(aes(x = TNFa_APC_Lin)) +
  geom_density(fill = "gray80") +
  geom_vline(xintercept = apc_cut, 
             color = "red") +
   geom_text(data = clean_trans_nondebris_tfna_pos |> 
              filter(treatment == "MEDIA",
                     antibody == "ISOTYPE"), 
             aes(label = paste0(perc_tfna_pos, 
                                "% cells\nTNF-Î± +'ve\nMFI = ",
                                mean_apc)), 
             x = 1.7, 
             y = 2.1,
             colour = "red") +
  scale_y_continuous(expand = c(0, 0),
                     limits = c(0, 2.5),
                     name = "Density") +
  scale_x_continuous(name = "Logicle transformed APC TNF-Î± signal") +
  theme_bw()

```

This has several advantages:

-   if the data changes, the plot annotation will update automatically just as the distribution will.

-   extending to multiple facets requires little extra work.

### Write to file

ðŸŽ¬ Assign the plot to `apc_distibution_media_isotype`

```{r}
apc_distibution_media_isotype <- clean_trans_nondebris |> 
  filter(treatment == "MEDIA",
         antibody == "ISOTYPE") |>
  ggplot(aes(x = TNFa_APC_Lin)) +
  geom_density(fill = "gray80") +
  geom_vline(xintercept = apc_cut, 
             color = "red") +
   geom_text(data = clean_trans_nondebris_tfna_pos |> 
              filter(treatment == "MEDIA",
                     antibody == "ISOTYPE"), 
             aes(label = paste0(perc_tfna_pos, 
                                "% cells\nTNF-Î± +'ve\nMFI = ",
                                mean_apc)), 
             x = 1.7, 
             y = 2.1,
             colour = "red") +
  scale_y_continuous(expand = c(0, 0),
                     limits = c(0, 2.5),
                     name = "Density") +
  scale_x_continuous(name = "Logicle transformed APC TNF-Î± signal") +
  theme_bw()
```



ðŸŽ¬ Save the plot to a file:

```{r}
ggsave("figures/apc_distibution_media_isotype.png",
       device = "png",
       plot = apc_distibution_media_isotype,
       width = 4,
       height = 2.5,
       units = "in",
       dpi = 300)
```


### Multiple facets

To plot all the samples in one go we can use `facet_grid()`.  `treatment ~ antibody` puts the treatments in rows and the antibodies in columns. Of course, we now don't need to filter the data to a single sample.

ðŸŽ¬ Plot the distribution of the APC TNF-Î± signal for all samples:


```{r}

clean_trans_nondebris |> 
  ggplot(aes(x = TNFa_APC_Lin)) +
  geom_density(fill = "gray80") +
  geom_vline(xintercept = apc_cut, 
             color = "red") +
   geom_text(data = clean_trans_nondebris_tfna_pos, 
             aes(label = paste0(perc_tfna_pos, 
                                "% cells\nTNF-Î± +'ve\nMFI = ",
                                mean_apc)), 
             x = 4, 
             y = 1.8,
             colour = "red") +
  scale_y_continuous(expand = c(0, 0),
                     limits = c(0, 2.5),
                     name = "Density") +
  scale_x_continuous(name = "Logicle transformed APC TNF-Î± signal") +
  facet_grid(treatment ~ antibody) +
  theme_bw()
```


You can combine these ideas to do facet plots of a subset of the samples.

### Overlay instead of facets

```{r}
clean_trans_nondebris |> 
   filter(treatment == "MEDIA") |>
   ggplot(aes(x = TNFa_APC_Lin, fill = antibody)) +
   geom_density(alpha = 0.3) +
   geom_vline(xintercept = apc_cut, 
              color = "red") +
   scale_fill_viridis_d(name = NULL) +
   scale_y_continuous(expand = c(0, 0),
                      limits = c(0, 2.5)) +
   scale_x_continuous(name = "Logicle transformed APC TNF-Î± signal") +
   theme_bw() +
   theme(legend.position = c(0.8, 0.85)) 
```






## Percentage of cells in each quadrant

Calculate the the percentage of cells in each quadrant of a quadrant gated gated plot of TNFa_APC_Lin signal against the E_coli_FITC_Lin


```{r}
 ## summarise the number of FITC +'ve cells in each sample  
clean_trans_nondebris_fitc_pos <- clean_trans_nondebris |>
  filter(fitc == "FITC +'ve") |>
  group_by(antibody, treatment, .drop = FALSE) |>
  summarise(n_pos_fitc = n(),
            mean_fitc = round(mean(E_coli_FITC_Lin), 2))

## join the summary with the summary of the number of cells in each sample
## and calculate the percentage of cells that are FITC +'ve
clean_trans_nondebris_fitc_pos <- 
  clean_trans_nondebris_fitc_pos |> 
  left_join(clean_trans_nondebris_n, by = c("antibody", "treatment")) |> 
  mutate(perc_fitc_pos = round(n_pos_fitc/n_nondebris * 100, 1) )




## calculate the percentage of cells in each quadrant
all_combin_n <- clean_trans_nondebris |> 
  group_by(antibody, treatment, tnfa, fitc, .drop = FALSE) |>
  summarise(n = n())

all_combin_perc <- clean_trans_nondebris_n |> 
  select(n_nondebris, antibody, treatment) |> 
  right_join(all_combin_n, by = c("antibody", "treatment")) |> 
  mutate(perc = round(n / n_nondebris * 100, 1)) |> 
  filter(perc > 0)


```





## Importing from google sheets

The [BIO00066I Biomedical Sciences class data](https://docs.google.com/spreadsheets/d/104EXdgsiIq-FuRF9Ly9zewEVdpkVWbyOwxSAmiqJepg/edit#gid=0) are in a google sheet.
You can download the file as an excel file for .csv.
file but it is also possible to import the data directly from the google sheet into R.
Use whatever you prefer.
An advantage of using the google sheet is you won't have to remember to download the data when someone updates it.

You can use the `googlesheets4` package [@googlesheets4] to do this.

```{r}
library(googlesheets4)
```


```{r}

```



# Independent study following the workshop

[Consolidate](study_after_workshop.qmd)

# The Code file

This contains all the code needed in the workshop even where it is not visible on the webpage.

The `workshop.qmd` file is the file I use to compile the practical.
Qmd stands for Quarto markdown.
It allows code and ordinary text to be interweaved to produce well-formatted reports including webpages.
[View the Qmd in Browser](https://github.com/3mmaRand/R4BABS/blob/main/r4babs4/week-6/workshop.qmd).
Coding and thinking answers are marked with `#---CODING ANSWER---` and `#---THINKING ANSWER---`

Pages made with R [@R-core], Quarto [@allaire2022], `knitr` [@knitr], `kableExtra` [@kableExtra]

# References
